<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Shinobi Hospital — Enhanced Silhouette (black bg)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body{margin:0;height:100%;background:#0b0f14;color:#cbd5e1;font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif}
    #hud{position:fixed;left:12px;top:12px;padding:10px 12px;background:rgba(0,0,0,.45);border:1px solid rgba(255,255,255,.08);border-radius:10px;line-height:1.35;z-index:10}
    #hud b{color:#fff}
    .btn{display:inline-block;margin-top:6px;padding:6px 10px;border-radius:8px;background:#1f2837;border:1px solid #324156;color:#bcd1ff;cursor:pointer}
    .btn:hover{background:#263145}
    canvas{display:block}
  </style>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <div id="hud">
    <div><b>Shinobi Hospital</b> — enhanced silhouette (skirt roof + decks + turret + tank)</div>
    <button class="btn" id="export">Export JSON</button>
  </div>

  <script type="module">
    // ----------------------- SPEC OBJECT -----------------------
    const ShinobiHospital = {
      id: "shinobi_hospital_v7_enhanced",
      version: 7,
      meta: { author: "Anton / Lord Tsarcasm", category: "civic", tags: ["hospital","konoha-style","3F"] },

      bounds: { width: 56, depth: 18, height: 15 },
      storeys: [{height:4.2},{height:4.2},{height:4.2}],
      bay: { countLeft: 4, countRight: 4, spacing: 5.5 },

      entry: {
        width: 10, depth: 3.8, height: 6.6,
        canopy: { width: 9.2, radius: 1.1, arc: Math.PI/2, depth: 0.9 },
        signPlate: { width: 9.6, height: 3.2, thickness: 0.25, trim: 0.18 },
        emblem: { radius: 0.95, thickness: 0.22, ring: 0.12, tube: 0.06 },
        columns: { radius: 0.28, height: 4.8, offsetX: 4.2 },
        door: { width: 4.8, height: 3.2, sill: 0.18, frame: 0.12, mullion: 0.12, leafThickness: 0.06, pushOut: -0.01 }
      },

      roof: {
        height: 2.3, eave: 0.95, soften: 0.5,
        skirt: { drop: 1.0, radius: 1.0, arc: Math.PI/2.3 }, // teal curved skirt roof that wraps the building
        decks: [
          { x:-15.5, z:-2.2, w:16, d:8, h:1.2 }, // left fenced deck under tank
          { x: 12.5, z:  3.5, w:14, d:7, h:1.2 }  // right fenced deck by turret
        ],
        tank:  { base: {w:6.5, d:6.5, h:1.6, lip:0.25}, drum:{r:1.9, h:2.6}, cap:{r:1.1,h:0.5}, x:-19, z:-5.4 },
        turret:{ sides: 8, r:2.2, h:2.8, windows:true, cone:{rTop:0.3, rBase:2.8, h:2.0, brimR:3.4, brimT:0.18}, x:19, z:5.6 },

        cables: [
          { pts:[[-22,0,-7],[-5,0,-8],[12,0,-6],[26,0,-7]], y: 17.8, r:0.08 },
          { pts:[[-23,0, 8],[-8,0, 7],[ 8,0, 8],[25,0, 7]], y: 17.9, r:0.08 }
        ]
      },

      facade: {
        pilaster: { width: 1.15, depth: 0.34, every: 5.5, round: 0.09 },
        beltBands: [
          { y: 5.15, height: 0.6, depth: 0.14, round: 0.07 },
          { y: 9.45, height: 0.6, depth: 0.14, round: 0.07 }
        ],
        window: {
          size: { w: 1.6, h: 2.2 }, inset: 0.14, frame: 0.08,
          grids: { cols: 2, rows: 2 },
          storeys: [
            { yBase: 1.2, awning: { radius: 0.6, arc: Math.PI/2.8 } },
            { yBase: 5.4, awning: { radius: 0.6, arc: Math.PI/2.8 }, archCap: true },
            { yBase: 9.6, awning: { radius: 0.6, arc: Math.PI/2.8 } }
          ]
        }
      },

      site: { path: { width: 6, depth: 8 }, hedge: { enabled: true, height: 1.0 } },

      palette: {
        plaster:"#eceae5", plasterShadow:"#dcd9d3", trim:"#e3d2a8",
        belt:"#e8a33a", signGreen:"#2f7d43", signTrim:"#f1d553",
        emblemRed:"#a52b2b", canopyBlue:"#5e93d2",
        windowGlass:"#88c7cf", windowFrame:"#2e4655",
        roofTeal:"#1d6f6a", roofTile:"#2a7c76",
        domeThatch:"#e0bb3e", metal:"#8aa0aa", darkMetal:"#3b4a56",
        hedge:"#2b6a3a", path:"#bfc5cc", fence:"#98a7b2", doorMetal:"#2e4655", cable:"#1b1b1b"
      }
    };
    window.ShinobiHospital = ShinobiHospital;

    // ----------------------- PREVIEW --------------------------
    import * as THREE from "three";
    import { OrbitControls } from "three/addons/controls/OrbitControls.js";
    import { RoundedBoxGeometry } from "three/addons/geometries/RoundedBoxGeometry.js";

    const P = ShinobiHospital.palette;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f14);
    const renderer = new THREE.WebGLRenderer({antialias:true});
    renderer.setSize(innerWidth, innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    const camera = new THREE.PerspectiveCamera(50, innerWidth/innerHeight, 0.1, 1000);
    camera.position.set(34, 22, 44);
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 7, 0); controls.update();

    scene.add(new THREE.HemisphereLight(0xffffff, 0x334455, .6));
    const sun = new THREE.DirectionalLight(0xffffff, 1.15);
    sun.position.set(24, 34, 14); sun.castShadow = true;
    sun.shadow.mapSize.set(2048,2048);
    scene.add(sun);

    const ground = new THREE.Mesh(
      new THREE.PlaneGeometry(240,180),
      new THREE.MeshStandardMaterial({color:0x0f141a, roughness:.95})
    );
    ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; scene.add(ground);

    const mat = c => new THREE.MeshStandardMaterial({color:new THREE.Color(c), roughness:.8, metalness:.05});
    const box = (w,h,d,c) => new THREE.Mesh(new THREE.BoxGeometry(w,h,d), mat(c));
    const rbox = (w,h,d,r,c)=> new THREE.Mesh(new RoundedBoxGeometry(w,h,d,r,3), mat(c));

    function arcCanopy(width, radius, arc, color){
      const g = new THREE.CylinderGeometry(radius, radius, width, 28, 1, true, Math.PI/2 - arc, arc);
      const m = mat(color); m.side = THREE.DoubleSide;
      const mesh = new THREE.Mesh(g, m);
      mesh.rotation.z = Math.PI/2;
      mesh.castShadow = true; mesh.receiveShadow = true;
      return mesh;
    }
    function tube(points, r, color){
      const curve = new THREE.CatmullRomCurve3(points);
      const geo = new THREE.TubeGeometry(curve, 100, r, 12, false);
      const m = new THREE.MeshStandardMaterial({color:new THREE.Color(color), metalness:.1, roughness:.8});
      return new THREE.Mesh(geo, m);
    }
    function railBetween(A, B, sizeY, sizeZ, color) {
      const dir = new THREE.Vector3().subVectors(B, A);
      const rail = new THREE.Mesh(
        new THREE.BoxGeometry(dir.length(), sizeY, sizeZ),
        new THREE.MeshStandardMaterial({ color, metalness: .45, roughness: .5 })
      );
      rail.position.copy(A).add(B).multiplyScalar(0.5);
      rail.quaternion.setFromUnitVectors(new THREE.Vector3(1, 0, 0), dir.normalize());
      rail.castShadow = true;
      return rail;
    }

    function makeWindow(spec){
      const g = new THREE.Group();
      const { w, h } = spec.size;

      const recess = new THREE.Mesh(new THREE.BoxGeometry(w+0.02, h+0.02, 0.02),
                                    new THREE.MeshStandardMaterial({color:0x0e1419, roughness:1}));
      recess.position.z = -spec.inset; g.add(recess);

      const frame = new THREE.Mesh(new THREE.BoxGeometry(w+spec.frame*2, h+spec.frame*2, 0.08), mat(P.windowFrame));
      g.add(frame);

      const glass = new THREE.Mesh(new THREE.PlaneGeometry(w, h),
        new THREE.MeshPhysicalMaterial({color:P.windowGlass, roughness:.05, transmission:.5, thickness:.2}));
      glass.position.z = 0.051; g.add(glass);

      // grids
      for(let i=1;i<spec.grids.cols;i++){
        const v = new THREE.Mesh(new THREE.BoxGeometry(0.06, h, 0.06), mat(P.windowFrame));
        v.position.x = -w/2 + (w/spec.grids.cols)*i; v.position.z = 0.05; g.add(v);
      }
      for(let j=1;j<spec.grids.rows;j++){
        const hbar = new THREE.Mesh(new THREE.BoxGeometry(w, 0.06, 0.06), mat(P.windowFrame));
        hbar.position.y = -h/2 + (h/spec.grids.rows)*j; hbar.position.z = 0.05; g.add(hbar);
      }

      if (spec.archCap){
        const cap = rbox(w, 0.22, 0.08, 0.06, P.windowFrame);
        cap.position.y = h/2 + 0.15; g.add(cap);
      }
      if (spec.awning){
        // backplate + brackets to avoid floating
        const back = new THREE.Mesh(new THREE.BoxGeometry(w+0.24, 0.09, 0.18), mat(P.domeThatch));
        back.position.set(0, h/2 + 0.07, 0.09); g.add(back);
        const aw = arcCanopy(w+0.24, spec.awning.radius, spec.awning.arc, P.domeThatch);
        aw.position.set(0, h/2 + 0.07, 0.28); g.add(aw);
        // brackets
        for (const sx of [-1,1]){
          const br = new THREE.Mesh(new THREE.BoxGeometry(0.06,0.3,0.22), mat(P.windowFrame));
          br.position.set(sx*(w/2-0.08), h/2 - 0.02, 0.16);
          g.add(br);
        }
      }
      return g;
    }

    function makeDoor(spec, colorFrame, colorGlass){
      const g = new THREE.Group();
      const t = spec.leafThickness;
      const w = spec.width, h = spec.height;
      const frameTh = spec.frame;
      const mull = spec.mullion;

      const parts = [];
      parts.push(new THREE.Mesh(new THREE.BoxGeometry(frameTh, h+frameTh, t), new THREE.MeshStandardMaterial({color:colorFrame, metalness:.4, roughness:.5})));
      parts[0].position.set(-w/2 - frameTh/2, h/2, 0);
      parts.push(parts[0].clone()); parts[1].position.x = w/2 + frameTh/2;
      parts.push(new THREE.Mesh(new THREE.BoxGeometry(w+frameTh*2, frameTh, t), new THREE.MeshStandardMaterial({color:colorFrame, metalness:.4, roughness:.5})));
      parts[2].position.set(0, h + frameTh/2, 0);
      parts.push(new THREE.Mesh(new THREE.BoxGeometry(w+frameTh*2, frameTh, t), new THREE.MeshStandardMaterial({color:colorFrame, metalness:.4, roughness:.5})));
      parts[3].position.set(0, -frameTh/2, 0);
      parts.forEach(p=>{p.castShadow = true; g.add(p);});

      const mullion = new THREE.Mesh(new THREE.BoxGeometry(mull, h, t), new THREE.MeshStandardMaterial({color:colorFrame, metalness:.4, roughness:.5}));
      mullion.position.set(0, h/2, 0); g.add(mullion);

      function leaf(sign){
        const lg = new THREE.Group();
        const leafW = w/2 - mull/2 - 0.02;
        const frame = new THREE.Mesh(new THREE.BoxGeometry(leafW, h, t), new THREE.MeshStandardMaterial({color:colorFrame, metalness:.35, roughness:.55}));
        frame.position.z = 0.001;
        const glass = new THREE.Mesh(new THREE.PlaneGeometry(leafW - 0.18, h - 0.18),
          new THREE.MeshPhysicalMaterial({color:colorGlass, transmission:.55, roughness:.08, thickness:.2}));
        glass.position.z = 0.01;
        lg.add(frame, glass);
        lg.position.x = sign * (leafW/2 + mull/2);
        return lg;
      }
      g.add(leaf(-1), leaf(1));
      return g;
    }

    function buildHospital(spec){
      const root = new THREE.Group();
      const W=spec.bounds.width, D=spec.bounds.depth, H=spec.bounds.height;

      // Main plaster block
      const body = box(W, H, D, P.plaster); body.position.y = H/2; root.add(body);

      // Pilasters
      const pilW = spec.facade.pilaster.width, pilD = spec.facade.pilaster.depth;
      const baysTotal = spec.bay.countLeft + spec.bay.countRight + 1;
      const bayW = spec.bay.spacing;
      const startX = -((baysTotal*bayW)/2) + bayW/2;
      const facadeZ = D/2 + 0.001;
      for(let i=0;i<=baysTotal;i++){
        const x = -W/2 + pilW/2 + i*bayW;
        const pil = rbox(pilW, H, pilD, spec.facade.pilaster.round, P.plasterShadow);
        pil.position.set(x, H/2, facadeZ - pilD/2); root.add(pil);
      }

      // Belts
      for(const band of spec.facade.beltBands){
        const b = rbox(W-2*pilD, band.height, band.depth, band.round, P.belt);
        b.position.set(0, band.y + band.height/2, facadeZ + band.depth/2 - pilD/2);
        root.add(b);
      }

      // Windows
      function placeWindows(colCenterX){
        for(let s=0; s<spec.storeys.length; s++){
          const ws = {...spec.facade.window, ...spec.facade.window.storeys[s]};
          const w = makeWindow(ws);
          w.position.set(colCenterX, ws.yBase + ws.size.h/2, facadeZ + 0.04);
          root.add(w);
        }
      }
      for(let i=0;i<baysTotal;i++){
        const isEntry = (i===spec.bay.countLeft);
        const colCenterX = startX + i*bayW;
        if(!isEntry) placeWindows(colCenterX);
      }

      // Entry / vestibule
      const e = spec.entry;
      const vestibule = rbox(e.width, e.height, e.depth, 0.18, P.plaster);
      vestibule.position.set(0, e.height/2, facadeZ + e.depth/2 + 0.02);
      root.add(vestibule);

      const colL = new THREE.Mesh(new THREE.CylinderGeometry(e.columns.radius, e.columns.radius, e.columns.height, 22), mat(P.plaster));
      const colR = colL.clone();
      const frontZ = facadeZ + e.depth - 0.18;
      colL.position.set(-e.columns.offsetX, e.columns.height/2, frontZ);
      colR.position.set(+e.columns.offsetX, e.columns.height/2, frontZ);
      root.add(colL, colR);

      // Sign + emblem on wall
      const plate = rbox(e.signPlate.width, e.signPlate.height, e.signPlate.thickness, 0.12, P.signGreen);
      plate.position.set(0, 7.6, facadeZ + e.signPlate.thickness/2 - 0.03); root.add(plate);
      const trim = rbox(e.signPlate.width, e.signPlate.trim, e.signPlate.thickness+0.08, 0.08, P.signTrim);
      trim.position.set(0, 9.0, facadeZ + e.signPlate.thickness/2 - 0.04); root.add(trim);
      const emblemZ = facadeZ + e.signPlate.thickness + e.emblem.thickness/2;
      const emblem = new THREE.Mesh(new THREE.CylinderGeometry(e.emblem.radius, e.emblem.radius, e.emblem.thickness, 48),
        new THREE.MeshStandardMaterial({color:P.emblemRed, metalness:.25, roughness:.5}));
      emblem.rotation.x = Math.PI/2; emblem.position.set(0, 7.6, emblemZ); root.add(emblem);
      const ring = new THREE.Mesh(new THREE.TorusGeometry(e.emblem.radius + e.emblem.ring, e.emblem.tube, 16, 64),
        new THREE.MeshStandardMaterial({color:P.signTrim, metalness:.65, roughness:.35}));
      ring.position.set(0, 7.6, emblemZ + 0.001); root.add(ring);

      // Canopy on vestibule
      const canopy = arcCanopy(e.canopy.width, e.canopy.radius, e.canopy.arc, P.canopyBlue);
      canopy.position.set(0, 5.9, facadeZ + e.depth + 0.02); root.add(canopy);

      // Door
      const door = makeDoor(e.door, P.doorMetal, P.windowGlass);
      door.position.set(0, e.door.sill, facadeZ + e.depth + e.door.pushOut); root.add(door);

      // Upper roof
      const R = spec.roof;
      const roofTop = H + R.height;
      const roof = rbox(W+R.eave*2, R.height, D+R.eave*2, R.soften, P.roofTile);
      roof.position.y = H + R.height/2; root.add(roof);

      // Curved skirt roof wrapping all sides (teal eaves)
      const skirtY = H + 0.2;
      const skirtR = R.skirt.radius, skirtArc = R.skirt.arc;
      // long sides
      const skirtFront = arcCanopy(W+0.2, skirtR, skirtArc, P.roofTeal);
      skirtFront.position.set(0, skirtY, D/2 + 0.01); root.add(skirtFront);
      const skirtBack = arcCanopy(W+0.2, skirtR, skirtArc, P.roofTeal);
      skirtBack.rotation.y = Math.PI; skirtBack.position.set(0, skirtY, -D/2 - 0.01); root.add(skirtBack);
      // short sides
      const skirtLeft = arcCanopy(D+0.2, skirtR, skirtArc, P.roofTeal);
      skirtLeft.rotation.y = -Math.PI/2; skirtLeft.position.set(-W/2-0.01, skirtY, 0); root.add(skirtLeft);
      const skirtRight = arcCanopy(D+0.2, skirtR, skirtArc, P.roofTeal);
      skirtRight.rotation.y = Math.PI/2; skirtRight.position.set(W/2+0.01, skirtY, 0); root.add(skirtRight);

      // Rooftop fenced decks (frame + mesh impression)
      for(const deck of R.decks){
        const y0 = roofTop + deck.h/2;
        const slab = rbox(deck.w, deck.h, deck.d, 0.08, P.plasterShadow);
        slab.position.set(deck.x, y0, deck.z); root.add(slab);

        const inset = 0.4, fh = 1.25, rails = [0.45, 0.95];
        const corners = [
          new THREE.Vector3(deck.x-deck.w/2+inset, y0+deck.h/2, deck.z-deck.d/2+inset),
          new THREE.Vector3(deck.x+deck.w/2-inset, y0+deck.h/2, deck.z-deck.d/2+inset),
          new THREE.Vector3(deck.x+deck.w/2-inset, y0+deck.h/2, deck.z+deck.d/2-inset),
          new THREE.Vector3(deck.x-deck.w/2+inset, y0+deck.h/2, deck.z+deck.d/2-inset)
        ];
        const fence = new THREE.Group();
        function seg(A,B){
          const len = A.distanceTo(B);
          const posts = Math.max(1, Math.floor(len/2.4));
          for(let i=0;i<=posts;i++){
            const t=i/posts, p=new THREE.Vector3().lerpVectors(A,B,t);
            const post = new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.06,fh+0.02,16),
              new THREE.MeshStandardMaterial({color:P.fence, roughness:.6, metalness:.45}));
            post.position.set(p.x, A.y + (fh+0.02)/2, p.z); post.castShadow=true; fence.add(post);
          }
          for(const frac of rails){
            const A2=A.clone(); A2.y += fh*frac;
            const B2=B.clone(); B2.y += fh*frac;
            fence.add(railBetween(A2,B2,0.06,0.06,P.fence));
          }
          // translucent infill for a mesh impression
          const mid = A.clone().add(B).multiplyScalar(0.5);
          const panel = new THREE.Mesh(new THREE.PlaneGeometry(len, fh*0.9),
            new THREE.MeshStandardMaterial({color:0xcad5de, transparent:true, opacity:0.12, roughness:.9, metalness:.1, side:THREE.DoubleSide}));
          panel.position.copy(mid); panel.position.y = A.y + fh*0.55;
          panel.lookAt(B.x,B.y,B.z); fence.add(panel);
        }
        seg(corners[0], corners[1]); seg(corners[1], corners[2]);
        seg(corners[2], corners[3]); seg(corners[3], corners[0]);
        root.add(fence);
      }

      // Water tank on square pedestal (left)
      {
        const t = R.tank;
        const base = rbox(t.base.w, t.base.h, t.base.d, 0.12, P.plaster);
        base.position.set(t.x, roofTop + t.base.h/2, t.z); root.add(base);
        const lip = rbox(t.base.w+0.6, t.base.lip, t.base.d+0.6, 0.05, P.plasterShadow);
        lip.position.set(t.x, roofTop + t.base.h + t.base.lip/2, t.z); root.add(lip);
        const drum = new THREE.Mesh(new THREE.CylinderGeometry(t.drum.r, t.drum.r, t.drum.h, 24), mat(P.metal));
        drum.position.set(t.x, roofTop + t.base.h + t.base.lip + t.drum.h/2, t.z); root.add(drum);
        const cap = new THREE.Mesh(new THREE.CylinderGeometry(t.cap.r, t.cap.r, t.cap.h, 24), mat(P.darkMetal));
        cap.position.set(t.x, drum.position.y + t.drum.h/2 + t.cap.h/2, t.z); root.add(cap);
      }

      // Octagonal turret with conical thatch roof (right)
      {
        const k = R.turret;
        const base = new THREE.Mesh(new THREE.CylinderGeometry(k.r, k.r, k.h, k.sides), mat(P.plaster));
        base.position.set(k.x, roofTop + k.h/2, k.z); root.add(base);

        if(k.windows){
          for(let i=0;i<k.sides;i++){
            const theta = (i/k.sides)*Math.PI*2;
            const wx = k.x + Math.cos(theta)*(k.r-0.1);
            const wz = k.z + Math.sin(theta)*(k.r-0.1);
            const win = new THREE.Mesh(new THREE.PlaneGeometry(0.8,1.0),
              new THREE.MeshPhysicalMaterial({color:P.windowGlass, transmission:.5, roughness:.08, thickness:.18}));
            win.position.set(wx, roofTop + 0.9, wz);
            win.lookAt(k.x, roofTop + 0.9, k.z);
            root.add(win);
          }
        }

        const brim = new THREE.Mesh(new THREE.CylinderGeometry(k.cone.brimR, k.cone.brimR, k.cone.brimT, 40), mat(P.domeThatch));
        brim.position.set(k.x, roofTop + k.h + k.cone.brimT/2, k.z); root.add(brim);

        const cone = new THREE.Mesh(
          new THREE.ConeGeometry(k.cone.rBase, k.cone.h, 40),
          mat(P.domeThatch)
        );
        cone.position.set(k.x, roofTop + k.h + k.cone.brimT + k.cone.h/2, k.z);
        root.add(cone);
      }

      // Cables draped across top
      for(const c of R.cables){
        const pts = c.pts.map(p=>new THREE.Vector3(p[0], c.y, p[2]));
        root.add(tube(pts, c.r, P.cable));
      }

      // Site path
      const path = box(spec.site.path.width, 0.08, spec.site.path.depth, P.path);
      path.position.set(0, 0.041, D/2 + spec.site.path.depth/2 - 0.2);
      path.receiveShadow = true; root.add(path);

      return root;
    }

    const hospital = buildHospital(ShinobiHospital);
    hospital.traverse(o=>{ if(o.isMesh){o.castShadow=true; o.receiveShadow = o.receiveShadow || false;}});
    scene.add(hospital);

    addEventListener('resize', ()=>{ camera.aspect = innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth, innerHeight);});
    (function animate(){ requestAnimationFrame(animate); renderer.render(scene,camera); })();

    // Export the enhanced spec as JSON
    document.getElementById('export').addEventListener('click', ()=>{
      const data = JSON.stringify(ShinobiHospital, null, 2);
      const blob = new Blob([data], {type:'application/json'});
      const a = Object.assign(document.createElement('a'), { href: URL.createObjectURL(blob), download: 'shinobi_hospital.enhanced.spec.json' });
      a.click(); URL.revokeObjectURL(a.href);
    });
  </script>
</body>
</html>
